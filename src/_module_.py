#!/usr/bin/python3

# 模块
# 把定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件就叫做模块
# 模块包括所有你定义的函数和变量的文件，后缀名为.py
# 模块可以被别的程序引入，以使用该模块中的函数等功能
# 也就是Java中的类

# 引入一个模块,可以使用, 隔开
import sys

# 当解释器遇到import语句，如果模块在当前的搜索路径就会被导入
# 搜索路径是一个解释器会先进行搜索的所有目录的列表
# 需要把命令放在脚本顶部

# 一个模块只会被导入一次，不管执行多少次import，可以防止导入的模块一遍又一遍的执行
# 搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块
# 也可以通过定义环境变量的方式来定义搜索路径
# 搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改
# 搜索路径被存储在sys模块中的path变量中
import sys

print(sys.path)

# 导入某个包下的某个文件，会直接执行整个文件，也可以获取某个变量或者函数，赋给新的变量或名称，以便直接调用
import src._data_structure_

mList = src._data_structure_.mList

# from ... import
# 从模块中导入一个指定的部分到当前的命名空间
# 这个声明不会把整个模块导入到当前的命名空间，只会将import的部分导入进来
from src._data_structure_ import fun

fun = fun()

# 把一个模块的所有内容全部导入到当前的命名空间
# from ... import *
# 这种声明不该被过多的使用

# 深入模块
# 模块除了方法定义，还包括了可执行的代码，这些代码一般用来初始化这个模块，只有在第一次被导入时才会被执行
# 每个模块有各自独立的符号表，在模块内部为所有的函数当做全局符号来使用
# 模块的作者可以大胆放心的在模块内部使用这些全局变量，不用担心把其他用户的全局变量搞花
# 模块是可以导入其他模块的
# 在一个模块的最前面用import导入一个模块，这只是惯例，而不是强制的
# 被导入的模块的名称将被放入当前操作的模块的符号表中
# 这种导入的方法不会把被导入的模块的名称放在当前的字符表中
# 通过from ... import一次性的把模块中的所有名称都导入到当前模块的字符表中
# 但是那些由单一下划线开头的名字不在此列
# 基本不会使用这种方式，其他来源的命名可能会覆盖已有的定义

# __name__属性
# 一个模块被另一个程序第一次引入时，其主程序将运行
# 在模块被引入时，模块的某一程序块不执行，可以用__name__来使改程序块仅在该模块自身运行时执行
# 每个模块都有一个__name__属性，当其值为__main__时，表明该模块自身在运行，否则是被引入
if __name__ == "__main__":
    print("程序自身在运行")
else:
    print("来自另一个模块")

# dir() 函数
# 可以找到模块内定义的所有名称，以一个字符串列表的形式返回
import src._data_structure_
print(dir(src._data_structure_))
# 如果没有给定参数，那么dir() 将会返回当前定义的所有名称

# 标准模块
# Python本身带着一些标准的模块库，有些模块直接被构建在解析器中，这些虽然不是一些语言内置的功能，但是却能高效的使用
# 甚至是系统级调用
# 这些组件会根据不同的操作系统进行不同形式的配置
# sys 内置在每一个Python解析器中
# sys.ps1和sys.ps2定义了主提示符和副提示符所对应的字符串（在交互模式中）

# 包
# 一种管理Python模块命名空间的形式，采用“点模块名称”
# 不用担心模块之间的全局变量相互影响，不同库之间的模块重名的情况
# 同Java包
# 在导入一个包时，Python会根据sys.path中的目录来寻找这个包中包含的子目录
# 目录只有包含一个叫__init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字不小心的影响搜索路径中的有效模块
# 用户可以每次只导入一个包里特定的模块，它必须使用全名去访问
# from 导入的模块可以直接访问，不需要前面的冗长的前缀
# form 中，import语法会首先把后面的名称当做一个包定义的名称，如果没找到，再试图按照一个模块去导入，如果还没找到，一个exc:ImportError异常将被抛出
# 反之，直接import 的导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者包，但是不可以是类，函数或变量的名称

# ？？？？
# 模块__all__ 含义





